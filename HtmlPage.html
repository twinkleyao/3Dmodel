<!DOCTYPE html>
<html lang="en">
	<head>
		<title>资环楼三维模型</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>

	<body>

		<script src="js/three.min.js"></script>
		<script src="js/OBJLoader.js"></script>
        <script src="js/DDSLoader.js"></script>
        <script src="js/MTLLoader.js"></script>
        <script src="js/stats.min.js"></script>
        <script src="js/Detector.js"></script>

        <script>
            var container, stats;
            var camera, scene, renderer;
            var mouseX = 0, mouseY = 0;
            var windowHalfX = window.innerWidth / 2;
            var windowHalfY = window.innerHeight / 2;
            init();
            animate();
            function init() {
                container = document.createElement('div');
                document.body.appendChild(container);
                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
                camera.position.x = -30;
                camera.position.y = 40;
                camera.position.z = 30;
                // scene
                scene = new THREE.Scene();
                var ambient = new THREE.AmbientLight(0x444444);
                scene.add(ambient);
                var directionalLight = new THREE.DirectionalLight(0xffeedd);
                directionalLight.position.set(0, 0, 1).normalize();
                scene.add(directionalLight);
                // model
                var onProgress = function (xhr) {
                    if (xhr.lengthComputable) {
                        var percentComplete = xhr.loaded / xhr.total * 100;
                        console.log(Math.round(percentComplete, 2) + '% downloaded');
                    }
                };
                var onError = function (xhr) { };
                THREE.Loader.Handlers.add(/\.dds$/i, new THREE.DDSLoader());
                var mtlLoader = new THREE.MTLLoader();
                mtlLoader.setBaseUrl('model2/');
                mtlLoader.setPath('model2/');
                mtlLoader.load('ecnu.mtl', function (materials) {
                    materials.preload();
                    var objLoader = new THREE.OBJLoader();
                    objLoader.setMaterials(materials);
                    objLoader.setPath('model2/');
                    objLoader.load('ecnu.obj', function (object) {
                        object.scale.set(5, 5, 5);
                        object.rotation.x = -0.5 * Math.PI;
                        scene.add(object);
                    }, onProgress, onError);
                });
                //
                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                container.appendChild(renderer.domElement);
                document.addEventListener('mousemove', onDocumentMouseMove, false);
                //
                window.addEventListener('resize', onWindowResize, false);
            }
            function onWindowResize() {
                windowHalfX = window.innerWidth / 2;
                windowHalfY = window.innerHeight / 2;
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            function onDocumentMouseMove(event) {
                mouseX = (event.clientX - windowHalfX) / 2;
                mouseY = (event.clientY - windowHalfY) / 2;
            }
            //
            function animate() {
                requestAnimationFrame(animate);
                render();
            }
            function render() {
                camera.position.x += (mouseX - camera.position.x) * .05;
                camera.position.y += (-mouseY - camera.position.y) * .05;
                camera.lookAt(scene.position);
                renderer.render(scene, camera);
            }
		</script>
	</body>
</html>